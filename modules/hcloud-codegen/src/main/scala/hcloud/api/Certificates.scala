/**
 * Hetzner Cloud API
 * Copied from the official API documentation for the Public Hetzner Cloud.
 *
 * The version of the OpenAPI document: f6511ca-dirty
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package hcloud.api

import hcloud.models.CreateCertificateRequest
import hcloud.models.CreateCertificateResponse
import hcloud.models.GetActionResponse
import hcloud.models.GetCertificateResponse
import hcloud.models.ListActionsResponse
import hcloud.models.ListCertificatesResponse
import hcloud.models.ReplaceCertificateRequest
import hcloud.models.ReplaceCertificateResponse
import hcloud.models.RetryIssuanceOrRenewalResponse
import hcloud.JsonSupport.{*, given}
import hcloud.FormSerializable
import hcloud.FormStyleFormat
import hcloud.HeaderSerializable
import hcloud.ApiKeyLocation
import hcloud.PathStyleFormat
import hcloud.PathSerializable
import hcloud.CookieSerializable
import hcloud.Helpers.*
import sttp.client4.jsoniter.*
import sttp.client4.*
import sttp.model.Method

object Certificates:
  def apply(baseUrl: String = "https://api.hetzner.cloud/v1"): Certificates[hcloud.Authorization.NoAuthorization.type] = Certificates(baseUrl, hcloud.Authorization.NoAuthorization)
  def withBasicAuth(baseUrl: String, username: String, password: String): Certificates[hcloud.Authorization.BasicAuth] =
    Certificates(baseUrl, hcloud.Authorization.BasicAuth(username, password))

  def withApiKeyAuth(baseUrl: String, apiKey: String): Certificates[hcloud.Authorization.ApiKey] =
    Certificates(baseUrl, hcloud.Authorization.ApiKey(apiKey))

  def withBearerTokenAuth(baseUrl: String, token: String): Certificates[hcloud.Authorization.BearerToken] =
    Certificates(baseUrl, hcloud.Authorization.BearerToken(token))

case class Certificates[Auth <: hcloud.Authorization] private (baseUrl: String, authConfig: hcloud.Authorization):
  def withBasicAuth(username: String, password: String): Certificates[hcloud.Authorization.BasicAuth] =
    copy(authConfig = hcloud.Authorization.BasicAuth(username, password))

  def withApiKeyAuth(apiKey: String): Certificates[hcloud.Authorization.ApiKey] =
    copy(authConfig = hcloud.Authorization.ApiKey(apiKey))

  def withNoAuth: Certificates[hcloud.Authorization.NoAuthorization.type] =
    copy(authConfig = hcloud.Authorization.NoAuthorization)

  def withBearerTokenAuth(token: String): Certificates[hcloud.Authorization.BearerToken] =
    copy(authConfig = hcloud.Authorization.BearerToken(token))

  /**
   * Creates a new Certificate.  The default type **uploaded** allows for uploading your existing `certificate` and `private_key` in PEM format. You have to monitor its expiration date and handle renewal yourself.  In contrast, type **managed** requests a new Certificate from *Let's Encrypt* for the specified `domain_names`. Only domains managed by *Hetzner DNS* are supported. We handle renewal and timely alert the project owner via email if problems occur.  For type `managed` Certificates the `action` key of the response contains the Action that allows for tracking the issuance process. For type `uploaded` Certificates the `action` is always null. 
   * 
   * Expected answers:
   *   code 201 : CreateCertificateResponse (The `certificate` key contains the Certificate that was just created. For type `managed` Certificates the `action` key contains the Action that allows for tracking the issuance process. For type `uploaded` Certificates the `action` is always null.)
   * 
   * Available security schemes:
   *   APIToken (http)
   * 
   * @param createCertificateRequest 
   */
  def createCertificate(createCertificateRequest: CreateCertificateRequest)(using Auth <:< hcloud.Authorization.BearerToken): sttp.client4.Request[Either[ResponseException[String], CreateCertificateResponse]] =
    val requestURL =
      uri"$baseUrl/certificates"

    basicRequest
      .method(Method.POST, requestURL)
      .contentType("application/json")
      .auth(authConfig)
      .body(asJson(createCertificateRequest))
      .response(asJson[CreateCertificateResponse])

  /**
   * Deletes a Certificate. 
   * 
   * Expected answers:
   *   code 204 :  (Certificate deleted.)
   * 
   * Available security schemes:
   *   APIToken (http)
   * 
   * @param id ID of the Certificate.
   */
  def deleteCertificate(id: Long)(using Auth <:< hcloud.Authorization.BearerToken): sttp.client4.Request[Either[ResponseException[String], Unit]] =
    val idPathParam = PathSerializable.serialize("id", id, PathStyleFormat.SIMPLE, false)
    val requestURL =
      uri"$baseUrl/certificates/${idPathParam}"

    basicRequest
      .method(Method.DELETE, requestURL)
      .contentType("application/json")
      .auth(authConfig)
      .response(asString.mapWithMetadata(ResponseAs.deserializeRightWithError(_ => Right(()))))

  /**
   * Returns a specific Action for a Certificate. Only type `managed` Certificates have Actions. 
   * 
   * Expected answers:
   *   code 200 : GetActionResponse (The `action` key contains the Certificate Action.)
   * 
   * Available security schemes:
   *   APIToken (http)
   * 
   * @param id ID of the Certificate.
   * @param actionId ID of the Action.
   */
  def getActionForCertificate(id: Long, actionId: Long)(using Auth <:< hcloud.Authorization.BearerToken): sttp.client4.Request[Either[ResponseException[String], GetActionResponse]] =
    val idPathParam = PathSerializable.serialize("id", id, PathStyleFormat.SIMPLE, false)
    val actionIdPathParam = PathSerializable.serialize("action_id", actionId, PathStyleFormat.SIMPLE, false)
    val requestURL =
      uri"$baseUrl/certificates/${idPathParam}/actions/${actionIdPathParam}"

    basicRequest
      .method(Method.GET, requestURL)
      .contentType("application/json")
      .auth(authConfig)
      .response(asJson[GetActionResponse])

  /**
   * Gets a specific Certificate object. 
   * 
   * Expected answers:
   *   code 200 : GetCertificateResponse (The `certificate` key contains a Certificate object.)
   * 
   * Available security schemes:
   *   APIToken (http)
   * 
   * @param id ID of the Certificate.
   */
  def getCertificate(id: Long)(using Auth <:< hcloud.Authorization.BearerToken): sttp.client4.Request[Either[ResponseException[String], GetCertificateResponse]] =
    val idPathParam = PathSerializable.serialize("id", id, PathStyleFormat.SIMPLE, false)
    val requestURL =
      uri"$baseUrl/certificates/${idPathParam}"

    basicRequest
      .method(Method.GET, requestURL)
      .contentType("application/json")
      .auth(authConfig)
      .response(asJson[GetCertificateResponse])

  /**
   * Returns a specific Action object. 
   * 
   * Expected answers:
   *   code 200 : GetActionResponse (The `action` key in the reply has this structure.)
   * 
   * Available security schemes:
   *   APIToken (http)
   * 
   * @param id ID of the Action.
   */
  def getCertificateAction(id: Long)(using Auth <:< hcloud.Authorization.BearerToken): sttp.client4.Request[Either[ResponseException[String], GetActionResponse]] =
    val idPathParam = PathSerializable.serialize("id", id, PathStyleFormat.SIMPLE, false)
    val requestURL =
      uri"$baseUrl/certificates/actions/${idPathParam}"

    basicRequest
      .method(Method.GET, requestURL)
      .contentType("application/json")
      .auth(authConfig)
      .response(asJson[GetActionResponse])

  /**
   * Returns all Action objects for a Certificate. You can sort the results by using the `sort` URI parameter, and filter them with the `status` parameter.  Only type `managed` Certificates can have Actions. For type `uploaded` Certificates the `actions` key will always contain an empty array. 
   * 
   * Expected answers:
   *   code 200 : ListActionsResponse (The `actions` key contains a list of Actions.)
   * 
   * Available security schemes:
   *   APIToken (http)
   * 
   * @param id ID of the Certificate.
   * @param sort Sort actions by field and direction. Can be used multiple times. For more information, see \"Sorting\". 
   * @param status Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses. 
   * @param page Page number to return. For more information, see \"Pagination\".
   * @param perPage Maximum number of entries returned per page. For more information, see \"Pagination\".
   */
  def listActionsForCertificate(id: Long, sort: Seq[String], status: Seq[String], page: Option[Long] = scala.None, perPage: Option[Long] = scala.None)(using Auth <:< hcloud.Authorization.BearerToken): sttp.client4.Request[Either[ResponseException[String], ListActionsResponse]] =
    val idPathParam = PathSerializable.serialize("id", id, PathStyleFormat.SIMPLE, false)
    val requestURL =
      uri"$baseUrl/certificates/${idPathParam}/actions"
        .addParams(FormSerializable.serialize("sort", sort, FormStyleFormat.FORM, true): _*)
        .addParams(FormSerializable.serialize("status", status, FormStyleFormat.FORM, true): _*)
        .addParams(FormSerializable.serialize("page", page, FormStyleFormat.FORM, true): _*)
        .addParams(FormSerializable.serialize("per_page", perPage, FormStyleFormat.FORM, true): _*)

    basicRequest
      .method(Method.GET, requestURL)
      .contentType("application/json")
      .auth(authConfig)
      .response(asJson[ListActionsResponse])

  /**
   * Returns all Action objects. You can `sort` the results by using the sort URI parameter, and filter them with the `status` and `id` parameter. 
   * 
   * Expected answers:
   *   code 200 : ListActionsResponse (The `actions` key contains a list of Actions.)
   * 
   * Available security schemes:
   *   APIToken (http)
   * 
   * @param id Filter the actions by ID. Can be used multiple times. The response will only contain actions matching the specified IDs. 
   * @param sort Sort actions by field and direction. Can be used multiple times. For more information, see \"Sorting\". 
   * @param status Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses. 
   * @param page Page number to return. For more information, see \"Pagination\".
   * @param perPage Maximum number of entries returned per page. For more information, see \"Pagination\".
   */
  def listCertificateActions(id: Seq[Long], sort: Seq[String], status: Seq[String], page: Option[Long] = scala.None, perPage: Option[Long] = scala.None)(using Auth <:< hcloud.Authorization.BearerToken): sttp.client4.Request[Either[ResponseException[String], ListActionsResponse]] =
    val requestURL =
      uri"$baseUrl/certificates/actions"
        .addParams(FormSerializable.serialize("id", id, FormStyleFormat.FORM, true): _*)
        .addParams(FormSerializable.serialize("sort", sort, FormStyleFormat.FORM, true): _*)
        .addParams(FormSerializable.serialize("status", status, FormStyleFormat.FORM, true): _*)
        .addParams(FormSerializable.serialize("page", page, FormStyleFormat.FORM, true): _*)
        .addParams(FormSerializable.serialize("per_page", perPage, FormStyleFormat.FORM, true): _*)

    basicRequest
      .method(Method.GET, requestURL)
      .contentType("application/json")
      .auth(authConfig)
      .response(asJson[ListActionsResponse])

  /**
   * Returns all Certificate objects. 
   * 
   * Expected answers:
   *   code 200 : ListCertificatesResponse (The `certificates` key contains an array of Certificate objects.)
   * 
   * Available security schemes:
   *   APIToken (http)
   * 
   * @param sort Sort resources by field and direction. Can be used multiple times. For more information, see \"Sorting\". 
   * @param name Filter resources by their name. The response will only contain the resources matching exactly the specified name. 
   * @param labelSelector Filter resources by labels. The response will only contain resources matching the label selector. For more information, see \"Label Selector\". 
   * @param `type` Filter resources by type. Can be used multiple times. The response will only contain the resources with the specified type. 
   * @param page Page number to return. For more information, see \"Pagination\".
   * @param perPage Maximum number of entries returned per page. For more information, see \"Pagination\".
   */
  def listCertificates(sort: Seq[String], name: Option[String] = scala.None, labelSelector: Option[String] = scala.None, `type`: Seq[String], page: Option[Long] = scala.None, perPage: Option[Long] = scala.None)(using Auth <:< hcloud.Authorization.BearerToken): sttp.client4.Request[Either[ResponseException[String], ListCertificatesResponse]] =
    val requestURL =
      uri"$baseUrl/certificates"
        .addParams(FormSerializable.serialize("sort", sort, FormStyleFormat.FORM, true): _*)
        .addParams(FormSerializable.serialize("name", name, FormStyleFormat.FORM, true): _*)
        .addParams(FormSerializable.serialize("label_selector", labelSelector, FormStyleFormat.FORM, true): _*)
        .addParams(FormSerializable.serialize("type", `type`, FormStyleFormat.FORM, true): _*)
        .addParams(FormSerializable.serialize("page", page, FormStyleFormat.FORM, true): _*)
        .addParams(FormSerializable.serialize("per_page", perPage, FormStyleFormat.FORM, true): _*)

    basicRequest
      .method(Method.GET, requestURL)
      .contentType("application/json")
      .auth(authConfig)
      .response(asJson[ListCertificatesResponse])

  /**
   * Updates the Certificate properties.  Note: if the Certificate object changes during the request, the response will be a “conflict” error. 
   * 
   * Expected answers:
   *   code 200 : ReplaceCertificateResponse (The `certificate` key contains the Certificate that was just updated.)
   * 
   * Available security schemes:
   *   APIToken (http)
   * 
   * @param id ID of the Certificate.
   * @param replaceCertificateRequest 
   */
  def replaceCertificate(id: Long, replaceCertificateRequest: ReplaceCertificateRequest)(using Auth <:< hcloud.Authorization.BearerToken): sttp.client4.Request[Either[ResponseException[String], ReplaceCertificateResponse]] =
    val idPathParam = PathSerializable.serialize("id", id, PathStyleFormat.SIMPLE, false)
    val requestURL =
      uri"$baseUrl/certificates/${idPathParam}"

    basicRequest
      .method(Method.PUT, requestURL)
      .contentType("application/json")
      .auth(authConfig)
      .body(asJson(replaceCertificateRequest))
      .response(asJson[ReplaceCertificateResponse])

  /**
   * Retry a failed Certificate issuance or renewal.  Only applicable if the type of the Certificate is `managed` and the issuance or renewal status is `failed`.  #### Call specific error codes  | Code                                                    | Description                                                               | |---------------------------------------------------------|---------------------------------------------------------------------------| | `caa_record_does_not_allow_ca`                          | CAA record does not allow certificate authority                           | | `ca_dns_validation_failed`                              | Certificate Authority: DNS validation failed                              | | `ca_too_many_authorizations_failed_recently`            | Certificate Authority: Too many authorizations failed recently            | | `ca_too_many_certificates_issued_for_registered_domain` | Certificate Authority: Too many certificates issued for registered domain | | `ca_too_many_duplicate_certificates`                    | Certificate Authority: Too many duplicate certificates                    | | `could_not_verify_domain_delegated_to_zone`             | Could not verify domain delegated to zone                                 | | `dns_zone_not_found`                                    | DNS zone not found                                                        | | `dns_zone_is_secondary_zone`                            | DNS zone is a secondary zone                                              | 
   * 
   * Expected answers:
   *   code 201 : RetryIssuanceOrRenewalResponse (The `action` key contains the resulting Action.)
   * 
   * Available security schemes:
   *   APIToken (http)
   * 
   * @param id ID of the Certificate.
   */
  def retryIssuanceOrRenewal(id: Long)(using Auth <:< hcloud.Authorization.BearerToken): sttp.client4.Request[Either[ResponseException[String], RetryIssuanceOrRenewalResponse]] =
    val idPathParam = PathSerializable.serialize("id", id, PathStyleFormat.SIMPLE, false)
    val requestURL =
      uri"$baseUrl/certificates/${idPathParam}/actions/retry"

    basicRequest
      .method(Method.POST, requestURL)
      .contentType("application/json")
      .auth(authConfig)
      .response(asJson[RetryIssuanceOrRenewalResponse])

end Certificates