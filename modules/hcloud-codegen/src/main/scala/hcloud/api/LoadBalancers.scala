/**
 * Hetzner Cloud API
 * Copied from the official API documentation for the Public Hetzner Cloud.
 *
 * The version of the OpenAPI document: f6511ca-dirty
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package hcloud.api

import hcloud.models.AddServiceResponse
import hcloud.models.AddTargetResponse
import hcloud.models.AttachLoadBalancerToNetworkRequest
import hcloud.models.AttachLoadBalancerToNetworkResponse
import hcloud.models.ChangeAlgorithmResponse
import hcloud.models.ChangeLoadBalancerProtectionRequest
import hcloud.models.ChangeLoadBalancerProtectionResponse
import hcloud.models.ChangeReverseDnsEntryForThisLoadBalancerRequest
import hcloud.models.ChangeReverseDnsEntryForThisLoadBalancerResponse
import hcloud.models.ChangeTypeOfLoadBalancerRequest
import hcloud.models.ChangeTypeOfLoadBalancerResponse
import hcloud.models.CreateLoadBalancerRequest
import hcloud.models.CreateLoadBalancerResponse
import hcloud.models.DeleteServiceRequest
import hcloud.models.DeleteServiceResponse
import hcloud.models.DetachLoadBalancerFromNetworkRequest
import hcloud.models.DetachLoadBalancerFromNetworkResponse
import hcloud.models.DisablePublicInterfaceOfLoadBalancerResponse
import hcloud.models.EnablePublicInterfaceOfLoadBalancerResponse
import hcloud.models.GetActionResponse
import hcloud.models.GetLoadBalancerResponse
import hcloud.models.GetMetricsForLoadbalancerResponse
import hcloud.models.ListActionsResponse
import hcloud.models.ListLoadBalancersResponse
import hcloud.models.LoadBalancerAddTarget
import hcloud.models.LoadBalancerAlgorithm
import hcloud.models.LoadBalancerService
import hcloud.models.RemoveTargetRequest
import hcloud.models.RemoveTargetResponse
import hcloud.models.ReplaceLoadBalancerRequest
import hcloud.models.ReplaceLoadBalancerResponse
import hcloud.models.UpdateLoadBalancerService
import hcloud.models.UpdateServiceResponse
import hcloud.JsonSupport.{*, given}
import hcloud.FormSerializable
import hcloud.FormStyleFormat
import hcloud.HeaderSerializable
import hcloud.ApiKeyLocation
import hcloud.PathStyleFormat
import hcloud.PathSerializable
import hcloud.CookieSerializable
import hcloud.Helpers.*
import sttp.client4.jsoniter.*
import sttp.client4.*
import sttp.model.Method

object LoadBalancers:
  def apply(baseUrl: String = "https://api.hetzner.cloud/v1"): LoadBalancers[hcloud.Authorization.NoAuthorization.type] = LoadBalancers(baseUrl, hcloud.Authorization.NoAuthorization)
  def withBasicAuth(baseUrl: String, username: String, password: String): LoadBalancers[hcloud.Authorization.BasicAuth] =
    LoadBalancers(baseUrl, hcloud.Authorization.BasicAuth(username, password))

  def withApiKeyAuth(baseUrl: String, apiKey: String): LoadBalancers[hcloud.Authorization.ApiKey] =
    LoadBalancers(baseUrl, hcloud.Authorization.ApiKey(apiKey))

  def withBearerTokenAuth(baseUrl: String, token: String): LoadBalancers[hcloud.Authorization.BearerToken] =
    LoadBalancers(baseUrl, hcloud.Authorization.BearerToken(token))

case class LoadBalancers[Auth <: hcloud.Authorization] private (baseUrl: String, authConfig: hcloud.Authorization):
  def withBasicAuth(username: String, password: String): LoadBalancers[hcloud.Authorization.BasicAuth] =
    copy(authConfig = hcloud.Authorization.BasicAuth(username, password))

  def withApiKeyAuth(apiKey: String): LoadBalancers[hcloud.Authorization.ApiKey] =
    copy(authConfig = hcloud.Authorization.ApiKey(apiKey))

  def withNoAuth: LoadBalancers[hcloud.Authorization.NoAuthorization.type] =
    copy(authConfig = hcloud.Authorization.NoAuthorization)

  def withBearerTokenAuth(token: String): LoadBalancers[hcloud.Authorization.BearerToken] =
    copy(authConfig = hcloud.Authorization.BearerToken(token))

  /**
   * Adds a service to a Load Balancer.  #### Call specific error codes  | Code                       | Description                                             | |----------------------------|---------------------------------------------------------| | `source_port_already_used` | The source port you are trying to add is already in use | 
   * 
   * Expected answers:
   *   code 201 : AddServiceResponse (The `action` key contains the `add_service` Action.)
   * 
   * Available security schemes:
   *   APIToken (http)
   * 
   * @param id ID of the Load Balancer.
   * @param body 
   */
  def addService(id: Long, body: LoadBalancerService)(using Auth <:< hcloud.Authorization.BearerToken): sttp.client4.Request[Either[ResponseException[String], AddServiceResponse]] =
    val idPathParam = PathSerializable.serialize("id", id, PathStyleFormat.SIMPLE, false)
    val requestURL =
      uri"$baseUrl/load_balancers/${idPathParam}/actions/add_service"

    basicRequest
      .method(Method.POST, requestURL)
      .contentType("application/json")
      .auth(authConfig)
      .body(asJson(body))
      .response(asJson[AddServiceResponse])

  /**
   * Adds a target to a Load Balancer.  #### Call specific error codes  | Code                                      | Description                                                                                           | |-------------------------------------------|-------------------------------------------------------------------------------------------------------| | `cloud_resource_ip_not_allowed`           | The IP you are trying to add as a target belongs to a Hetzner Cloud resource                          | | `ip_not_owned`                            | The IP you are trying to add as a target is not owned by the Project owner                            | | `load_balancer_public_interface_disabled` | The Load Balancer's public network interface is disabled                                              | | `load_balancer_not_attached_to_network`   | The Load Balancer is not attached to a network                                                        | | `robot_unavailable`                       | Robot was not available. The caller may retry the operation after a short delay.                      | | `server_not_attached_to_network`          | The server you are trying to add as a target is not attached to the same network as the Load Balancer | | `missing_ipv4`                            | The server that you are trying to add as a public target does not have a public IPv4 address          | | `target_already_defined`                  | The Load Balancer target you are trying to define is already defined                                  | 
   * 
   * Expected answers:
   *   code 201 : AddTargetResponse (The `action` key contains the `add_target` Action.)
   * 
   * Available security schemes:
   *   APIToken (http)
   * 
   * @param id ID of the Load Balancer.
   * @param body 
   */
  def addTarget(id: Long, body: LoadBalancerAddTarget)(using Auth <:< hcloud.Authorization.BearerToken): sttp.client4.Request[Either[ResponseException[String], AddTargetResponse]] =
    val idPathParam = PathSerializable.serialize("id", id, PathStyleFormat.SIMPLE, false)
    val requestURL =
      uri"$baseUrl/load_balancers/${idPathParam}/actions/add_target"

    basicRequest
      .method(Method.POST, requestURL)
      .contentType("application/json")
      .auth(authConfig)
      .body(asJson(body))
      .response(asJson[AddTargetResponse])

  /**
   * Attach a Load Balancer to a Network.  **Call specific error codes**  | Code                             | Description                                                           | |----------------------------------|-----------------------------------------------------------------------| | `load_balancer_already_attached` | The Load Balancer is already attached to a network                    | | `ip_not_available`               | The provided Network IP is not available                              | | `no_subnet_available`            | No Subnet or IP is available for the Load Balancer within the network | 
   * 
   * Expected answers:
   *   code 201 : AttachLoadBalancerToNetworkResponse (The `action` key contains the `attach_to_network` Action.)
   * 
   * Available security schemes:
   *   APIToken (http)
   * 
   * @param id ID of the Load Balancer.
   * @param attachLoadBalancerToNetworkRequest 
   */
  def attachLoadBalancerToNetwork(id: Long, attachLoadBalancerToNetworkRequest: AttachLoadBalancerToNetworkRequest)(using Auth <:< hcloud.Authorization.BearerToken): sttp.client4.Request[Either[ResponseException[String], AttachLoadBalancerToNetworkResponse]] =
    val idPathParam = PathSerializable.serialize("id", id, PathStyleFormat.SIMPLE, false)
    val requestURL =
      uri"$baseUrl/load_balancers/${idPathParam}/actions/attach_to_network"

    basicRequest
      .method(Method.POST, requestURL)
      .contentType("application/json")
      .auth(authConfig)
      .body(asJson(attachLoadBalancerToNetworkRequest))
      .response(asJson[AttachLoadBalancerToNetworkResponse])

  /**
   * Change the algorithm that determines to which target new requests are sent. 
   * 
   * Expected answers:
   *   code 201 : ChangeAlgorithmResponse (The `action` key contains the `change_algorithm` Action.)
   * 
   * Available security schemes:
   *   APIToken (http)
   * 
   * @param id ID of the Load Balancer.
   * @param body 
   */
  def changeAlgorithm(id: Long, body: LoadBalancerAlgorithm)(using Auth <:< hcloud.Authorization.BearerToken): sttp.client4.Request[Either[ResponseException[String], ChangeAlgorithmResponse]] =
    val idPathParam = PathSerializable.serialize("id", id, PathStyleFormat.SIMPLE, false)
    val requestURL =
      uri"$baseUrl/load_balancers/${idPathParam}/actions/change_algorithm"

    basicRequest
      .method(Method.POST, requestURL)
      .contentType("application/json")
      .auth(authConfig)
      .body(asJson(body))
      .response(asJson[ChangeAlgorithmResponse])

  /**
   * Changes the protection configuration of a Load Balancer. 
   * 
   * Expected answers:
   *   code 201 : ChangeLoadBalancerProtectionResponse (The `action` key contains the `change_protection` Action.)
   * 
   * Available security schemes:
   *   APIToken (http)
   * 
   * @param id ID of the Load Balancer.
   * @param changeLoadBalancerProtectionRequest 
   */
  def changeLoadBalancerProtection(id: Long, changeLoadBalancerProtectionRequest: ChangeLoadBalancerProtectionRequest)(using Auth <:< hcloud.Authorization.BearerToken): sttp.client4.Request[Either[ResponseException[String], ChangeLoadBalancerProtectionResponse]] =
    val idPathParam = PathSerializable.serialize("id", id, PathStyleFormat.SIMPLE, false)
    val requestURL =
      uri"$baseUrl/load_balancers/${idPathParam}/actions/change_protection"

    basicRequest
      .method(Method.POST, requestURL)
      .contentType("application/json")
      .auth(authConfig)
      .body(asJson(changeLoadBalancerProtectionRequest))
      .response(asJson[ChangeLoadBalancerProtectionResponse])

  /**
   * Changes the hostname that will appear when getting the hostname belonging to the public IPs (IPv4 and IPv6) of this Load Balancer.  Floating IPs assigned to the Server are not affected by this. 
   * 
   * Expected answers:
   *   code 201 : ChangeReverseDnsEntryForThisLoadBalancerResponse (The `action` key in the reply contains an Action object with this structure.)
   * 
   * Available security schemes:
   *   APIToken (http)
   * 
   * @param id ID of the Load Balancer.
   * @param changeReverseDnsEntryForThisLoadBalancerRequest Select the IP address for which to change the DNS entry by passing `ip`. It can be either IPv4 or IPv6. The target hostname is set by passing `dns_ptr`, which must be a fully qualified domain name (FQDN) without trailing dot.
   */
  def changeReverseDnsEntryForThisLoadBalancer(id: Long, changeReverseDnsEntryForThisLoadBalancerRequest: ChangeReverseDnsEntryForThisLoadBalancerRequest)(using Auth <:< hcloud.Authorization.BearerToken): sttp.client4.Request[Either[ResponseException[String], ChangeReverseDnsEntryForThisLoadBalancerResponse]] =
    val idPathParam = PathSerializable.serialize("id", id, PathStyleFormat.SIMPLE, false)
    val requestURL =
      uri"$baseUrl/load_balancers/${idPathParam}/actions/change_dns_ptr"

    basicRequest
      .method(Method.POST, requestURL)
      .contentType("application/json")
      .auth(authConfig)
      .body(asJson(changeReverseDnsEntryForThisLoadBalancerRequest))
      .response(asJson[ChangeReverseDnsEntryForThisLoadBalancerResponse])

  /**
   * Changes the type (Max Services, Max Targets and Max Connections) of a Load Balancer.  **Call specific error codes**  | Code                         | Description                                                     | |------------------------------|-----------------------------------------------------------------| | `invalid_load_balancer_type` | The Load Balancer type does not fit for the given Load Balancer | 
   * 
   * Expected answers:
   *   code 201 : ChangeTypeOfLoadBalancerResponse (The `action` key contains the `change_load_balancer_type` Action.)
   * 
   * Available security schemes:
   *   APIToken (http)
   * 
   * @param id ID of the Load Balancer.
   * @param changeTypeOfLoadBalancerRequest 
   */
  def changeTypeOfLoadBalancer(id: Long, changeTypeOfLoadBalancerRequest: ChangeTypeOfLoadBalancerRequest)(using Auth <:< hcloud.Authorization.BearerToken): sttp.client4.Request[Either[ResponseException[String], ChangeTypeOfLoadBalancerResponse]] =
    val idPathParam = PathSerializable.serialize("id", id, PathStyleFormat.SIMPLE, false)
    val requestURL =
      uri"$baseUrl/load_balancers/${idPathParam}/actions/change_type"

    basicRequest
      .method(Method.POST, requestURL)
      .contentType("application/json")
      .auth(authConfig)
      .body(asJson(changeTypeOfLoadBalancerRequest))
      .response(asJson[ChangeTypeOfLoadBalancerResponse])

  /**
   * Creates a Load Balancer.  #### Call specific error codes  | Code                                    | Description                                                                                           | |-----------------------------------------|-------------------------------------------------------------------------------------------------------| | `cloud_resource_ip_not_allowed`         | The IP you are trying to add as a target belongs to a Hetzner Cloud resource                          | | `ip_not_owned`                          | The IP is not owned by the owner of the project of the Load Balancer                                  | | `load_balancer_not_attached_to_network` | The Load Balancer is not attached to a network                                                        | | `robot_unavailable`                     | Robot was not available. The caller may retry the operation after a short delay.                      | | `server_not_attached_to_network`        | The server you are trying to add as a target is not attached to the same network as the Load Balancer | | `source_port_already_used`              | The source port you are trying to add is already in use                                               | | `missing_ipv4`                          | The server that you are trying to add as a public target does not have a public IPv4 address          | | `target_already_defined`                | The Load Balancer target you are trying to define is already defined                                  | 
   * 
   * Expected answers:
   *   code 201 : CreateLoadBalancerResponse (The `load_balancer` key contains the Load Balancer that was just created.)
   * 
   * Available security schemes:
   *   APIToken (http)
   * 
   * @param createLoadBalancerRequest 
   */
  def createLoadBalancer(createLoadBalancerRequest: CreateLoadBalancerRequest)(using Auth <:< hcloud.Authorization.BearerToken): sttp.client4.Request[Either[ResponseException[String], CreateLoadBalancerResponse]] =
    val requestURL =
      uri"$baseUrl/load_balancers"

    basicRequest
      .method(Method.POST, requestURL)
      .contentType("application/json")
      .auth(authConfig)
      .body(asJson(createLoadBalancerRequest))
      .response(asJson[CreateLoadBalancerResponse])

  /**
   * Deletes a Load Balancer. 
   * 
   * Expected answers:
   *   code 204 :  (Load Balancer deleted.)
   * 
   * Available security schemes:
   *   APIToken (http)
   * 
   * @param id ID of the Load Balancer.
   */
  def deleteLoadBalancer(id: Long)(using Auth <:< hcloud.Authorization.BearerToken): sttp.client4.Request[Either[ResponseException[String], Unit]] =
    val idPathParam = PathSerializable.serialize("id", id, PathStyleFormat.SIMPLE, false)
    val requestURL =
      uri"$baseUrl/load_balancers/${idPathParam}"

    basicRequest
      .method(Method.DELETE, requestURL)
      .contentType("application/json")
      .auth(authConfig)
      .response(asString.mapWithMetadata(ResponseAs.deserializeRightWithError(_ => Right(()))))

  /**
   * Delete a service of a Load Balancer. 
   * 
   * Expected answers:
   *   code 201 : DeleteServiceResponse (The `action` key contains the `delete_service` Action.)
   * 
   * Available security schemes:
   *   APIToken (http)
   * 
   * @param id ID of the Load Balancer.
   * @param deleteServiceRequest 
   */
  def deleteService(id: Long, deleteServiceRequest: DeleteServiceRequest)(using Auth <:< hcloud.Authorization.BearerToken): sttp.client4.Request[Either[ResponseException[String], DeleteServiceResponse]] =
    val idPathParam = PathSerializable.serialize("id", id, PathStyleFormat.SIMPLE, false)
    val requestURL =
      uri"$baseUrl/load_balancers/${idPathParam}/actions/delete_service"

    basicRequest
      .method(Method.POST, requestURL)
      .contentType("application/json")
      .auth(authConfig)
      .body(asJson(deleteServiceRequest))
      .response(asJson[DeleteServiceResponse])

  /**
   * Detaches a Load Balancer from a network. 
   * 
   * Expected answers:
   *   code 201 : DetachLoadBalancerFromNetworkResponse (The `action` key contains the `detach_from_network` Action.)
   * 
   * Available security schemes:
   *   APIToken (http)
   * 
   * @param id ID of the Load Balancer.
   * @param detachLoadBalancerFromNetworkRequest 
   */
  def detachLoadBalancerFromNetwork(id: Long, detachLoadBalancerFromNetworkRequest: DetachLoadBalancerFromNetworkRequest)(using Auth <:< hcloud.Authorization.BearerToken): sttp.client4.Request[Either[ResponseException[String], DetachLoadBalancerFromNetworkResponse]] =
    val idPathParam = PathSerializable.serialize("id", id, PathStyleFormat.SIMPLE, false)
    val requestURL =
      uri"$baseUrl/load_balancers/${idPathParam}/actions/detach_from_network"

    basicRequest
      .method(Method.POST, requestURL)
      .contentType("application/json")
      .auth(authConfig)
      .body(asJson(detachLoadBalancerFromNetworkRequest))
      .response(asJson[DetachLoadBalancerFromNetworkResponse])

  /**
   * Disable the public interface of a Load Balancer. The Load Balancer will be not accessible from the internet via its public IPs.  #### Call specific error codes  | Code                                      | Description                                                                    | |-------------------------------------------|--------------------------------------------------------------------------------| | `load_balancer_not_attached_to_network`   |  The Load Balancer is not attached to a network                                | | `targets_without_use_private_ip`          | The Load Balancer has targets that use the public IP instead of the private IP | 
   * 
   * Expected answers:
   *   code 201 : DisablePublicInterfaceOfLoadBalancerResponse (The `action` key contains the `disable_public_interface` Action.)
   * 
   * Available security schemes:
   *   APIToken (http)
   * 
   * @param id ID of the Load Balancer.
   */
  def disablePublicInterfaceOfLoadBalancer(id: Long)(using Auth <:< hcloud.Authorization.BearerToken): sttp.client4.Request[Either[ResponseException[String], DisablePublicInterfaceOfLoadBalancerResponse]] =
    val idPathParam = PathSerializable.serialize("id", id, PathStyleFormat.SIMPLE, false)
    val requestURL =
      uri"$baseUrl/load_balancers/${idPathParam}/actions/disable_public_interface"

    basicRequest
      .method(Method.POST, requestURL)
      .contentType("application/json")
      .auth(authConfig)
      .response(asJson[DisablePublicInterfaceOfLoadBalancerResponse])

  /**
   * Enable the public interface of a Load Balancer. The Load Balancer will be accessible from the internet via its public IPs. 
   * 
   * Expected answers:
   *   code 201 : EnablePublicInterfaceOfLoadBalancerResponse (The `action` key contains the `enable_public_interface` Action.)
   * 
   * Available security schemes:
   *   APIToken (http)
   * 
   * @param id ID of the Load Balancer.
   */
  def enablePublicInterfaceOfLoadBalancer(id: Long)(using Auth <:< hcloud.Authorization.BearerToken): sttp.client4.Request[Either[ResponseException[String], EnablePublicInterfaceOfLoadBalancerResponse]] =
    val idPathParam = PathSerializable.serialize("id", id, PathStyleFormat.SIMPLE, false)
    val requestURL =
      uri"$baseUrl/load_balancers/${idPathParam}/actions/enable_public_interface"

    basicRequest
      .method(Method.POST, requestURL)
      .contentType("application/json")
      .auth(authConfig)
      .response(asJson[EnablePublicInterfaceOfLoadBalancerResponse])

  /**
   * Returns a specific Action for a Load Balancer. 
   * 
   * Expected answers:
   *   code 200 : GetActionResponse (The `action` key contains the Load Balancer Action.)
   * 
   * Available security schemes:
   *   APIToken (http)
   * 
   * @param id ID of the Load Balancer.
   * @param actionId ID of the Action.
   */
  def getActionForLoadBalancer(id: Long, actionId: Long)(using Auth <:< hcloud.Authorization.BearerToken): sttp.client4.Request[Either[ResponseException[String], GetActionResponse]] =
    val idPathParam = PathSerializable.serialize("id", id, PathStyleFormat.SIMPLE, false)
    val actionIdPathParam = PathSerializable.serialize("action_id", actionId, PathStyleFormat.SIMPLE, false)
    val requestURL =
      uri"$baseUrl/load_balancers/${idPathParam}/actions/${actionIdPathParam}"

    basicRequest
      .method(Method.GET, requestURL)
      .contentType("application/json")
      .auth(authConfig)
      .response(asJson[GetActionResponse])

  /**
   * Gets a specific Load Balancer object. 
   * 
   * Expected answers:
   *   code 200 : GetLoadBalancerResponse (The `load_balancer` key contains the Load Balancer.)
   * 
   * Available security schemes:
   *   APIToken (http)
   * 
   * @param id ID of the Load Balancer.
   */
  def getLoadBalancer(id: Long)(using Auth <:< hcloud.Authorization.BearerToken): sttp.client4.Request[Either[ResponseException[String], GetLoadBalancerResponse]] =
    val idPathParam = PathSerializable.serialize("id", id, PathStyleFormat.SIMPLE, false)
    val requestURL =
      uri"$baseUrl/load_balancers/${idPathParam}"

    basicRequest
      .method(Method.GET, requestURL)
      .contentType("application/json")
      .auth(authConfig)
      .response(asJson[GetLoadBalancerResponse])

  /**
   * Returns a specific Action object. 
   * 
   * Expected answers:
   *   code 200 : GetActionResponse (The `action` key in the reply has this structure.)
   * 
   * Available security schemes:
   *   APIToken (http)
   * 
   * @param id ID of the Action.
   */
  def getLoadBalancerAction(id: Long)(using Auth <:< hcloud.Authorization.BearerToken): sttp.client4.Request[Either[ResponseException[String], GetActionResponse]] =
    val idPathParam = PathSerializable.serialize("id", id, PathStyleFormat.SIMPLE, false)
    val requestURL =
      uri"$baseUrl/load_balancers/actions/${idPathParam}"

    basicRequest
      .method(Method.GET, requestURL)
      .contentType("application/json")
      .auth(authConfig)
      .response(asJson[GetActionResponse])

  /**
   * You must specify the type of metric to get: `open_connections`, `connections_per_second`, `requests_per_second` or `bandwidth`. You can also specify more than one type by comma separation, e.g. `requests_per_second,bandwidth`.  Depending on the type you will get different time series data:  |Type | Timeseries | Unit | Description | |---- |------------|------|-------------| | open_connections | open_connections | number | Open connections | | connections_per_second | connections_per_second | connections/s | Connections per second | | requests_per_second | requests_per_second | requests/s | Requests per second | | bandwidth | bandwidth.in | bytes/s | Ingress bandwidth | || bandwidth.out | bytes/s | Egress bandwidth |  Metrics are available for the last 30 days only.  If you do not provide the step argument we will automatically adjust it so that 200 samples are returned.  We limit the number of samples to a maximum of 500 and will adjust the step parameter accordingly. 
   * 
   * Expected answers:
   *   code 200 : GetMetricsForLoadbalancerResponse (The `metrics` key in the reply contains a metrics object with this structure.)
   * 
   * Available security schemes:
   *   APIToken (http)
   * 
   * @param id ID of the Load Balancer.
   * @param `type` Type of metrics to get.
   * @param start Start of period to get Metrics for (in ISO-8601 format).
   * @param end End of period to get Metrics for (in ISO-8601 format).
   * @param step Resolution of results in seconds.
   */
  def getMetricsForLoadbalancer(id: Long, `type`: Seq[String], start: String, end: String, step: Option[String] = scala.None)(using Auth <:< hcloud.Authorization.BearerToken): sttp.client4.Request[Either[ResponseException[String], GetMetricsForLoadbalancerResponse]] =
    val idPathParam = PathSerializable.serialize("id", id, PathStyleFormat.SIMPLE, false)
    val requestURL =
      uri"$baseUrl/load_balancers/${idPathParam}/metrics"
        .addParams(FormSerializable.serialize("type", `type`, FormStyleFormat.FORM, true): _*)
        .addParams(FormSerializable.serialize("start", start, FormStyleFormat.FORM, true): _*)
        .addParams(FormSerializable.serialize("end", end, FormStyleFormat.FORM, true): _*)
        .addParams(FormSerializable.serialize("step", step, FormStyleFormat.FORM, true): _*)

    basicRequest
      .method(Method.GET, requestURL)
      .contentType("application/json")
      .auth(authConfig)
      .response(asJson[GetMetricsForLoadbalancerResponse])

  /**
   * Returns all Action objects for a Load Balancer. You can sort the results by using the `sort` URI parameter, and filter them with the `status` parameter. 
   * 
   * Expected answers:
   *   code 200 : ListActionsResponse (The `actions` key contains a list of Actions.)
   * 
   * Available security schemes:
   *   APIToken (http)
   * 
   * @param id ID of the Load Balancer.
   * @param sort Sort actions by field and direction. Can be used multiple times. For more information, see \"Sorting\". 
   * @param status Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses. 
   * @param page Page number to return. For more information, see \"Pagination\".
   * @param perPage Maximum number of entries returned per page. For more information, see \"Pagination\".
   */
  def listActionsForLoadBalancer(id: Long, sort: Seq[String], status: Seq[String], page: Option[Long] = scala.None, perPage: Option[Long] = scala.None)(using Auth <:< hcloud.Authorization.BearerToken): sttp.client4.Request[Either[ResponseException[String], ListActionsResponse]] =
    val idPathParam = PathSerializable.serialize("id", id, PathStyleFormat.SIMPLE, false)
    val requestURL =
      uri"$baseUrl/load_balancers/${idPathParam}/actions"
        .addParams(FormSerializable.serialize("sort", sort, FormStyleFormat.FORM, true): _*)
        .addParams(FormSerializable.serialize("status", status, FormStyleFormat.FORM, true): _*)
        .addParams(FormSerializable.serialize("page", page, FormStyleFormat.FORM, true): _*)
        .addParams(FormSerializable.serialize("per_page", perPage, FormStyleFormat.FORM, true): _*)

    basicRequest
      .method(Method.GET, requestURL)
      .contentType("application/json")
      .auth(authConfig)
      .response(asJson[ListActionsResponse])

  /**
   * Returns all Action objects. You can `sort` the results by using the sort URI parameter, and filter them with the `status` and `id` parameter. 
   * 
   * Expected answers:
   *   code 200 : ListActionsResponse (The `actions` key contains a list of Actions.)
   * 
   * Available security schemes:
   *   APIToken (http)
   * 
   * @param id Filter the actions by ID. Can be used multiple times. The response will only contain actions matching the specified IDs. 
   * @param sort Sort actions by field and direction. Can be used multiple times. For more information, see \"Sorting\". 
   * @param status Filter the actions by status. Can be used multiple times. The response will only contain actions matching the specified statuses. 
   * @param page Page number to return. For more information, see \"Pagination\".
   * @param perPage Maximum number of entries returned per page. For more information, see \"Pagination\".
   */
  def listLoadBalancerActions(id: Seq[Long], sort: Seq[String], status: Seq[String], page: Option[Long] = scala.None, perPage: Option[Long] = scala.None)(using Auth <:< hcloud.Authorization.BearerToken): sttp.client4.Request[Either[ResponseException[String], ListActionsResponse]] =
    val requestURL =
      uri"$baseUrl/load_balancers/actions"
        .addParams(FormSerializable.serialize("id", id, FormStyleFormat.FORM, true): _*)
        .addParams(FormSerializable.serialize("sort", sort, FormStyleFormat.FORM, true): _*)
        .addParams(FormSerializable.serialize("status", status, FormStyleFormat.FORM, true): _*)
        .addParams(FormSerializable.serialize("page", page, FormStyleFormat.FORM, true): _*)
        .addParams(FormSerializable.serialize("per_page", perPage, FormStyleFormat.FORM, true): _*)

    basicRequest
      .method(Method.GET, requestURL)
      .contentType("application/json")
      .auth(authConfig)
      .response(asJson[ListActionsResponse])

  /**
   * Gets all existing Load Balancers that you have available. 
   * 
   * Expected answers:
   *   code 200 : ListLoadBalancersResponse (The `load_balancers` key contains a list of Load Balancers.)
   * 
   * Available security schemes:
   *   APIToken (http)
   * 
   * @param sort Sort resources by field and direction. Can be used multiple times. For more information, see \"Sorting\". 
   * @param name Filter resources by their name. The response will only contain the resources matching exactly the specified name. 
   * @param labelSelector Filter resources by labels. The response will only contain resources matching the label selector. For more information, see \"Label Selector\". 
   * @param page Page number to return. For more information, see \"Pagination\".
   * @param perPage Maximum number of entries returned per page. For more information, see \"Pagination\".
   */
  def listLoadBalancers(sort: Seq[String], name: Option[String] = scala.None, labelSelector: Option[String] = scala.None, page: Option[Long] = scala.None, perPage: Option[Long] = scala.None)(using Auth <:< hcloud.Authorization.BearerToken): sttp.client4.Request[Either[ResponseException[String], ListLoadBalancersResponse]] =
    val requestURL =
      uri"$baseUrl/load_balancers"
        .addParams(FormSerializable.serialize("sort", sort, FormStyleFormat.FORM, true): _*)
        .addParams(FormSerializable.serialize("name", name, FormStyleFormat.FORM, true): _*)
        .addParams(FormSerializable.serialize("label_selector", labelSelector, FormStyleFormat.FORM, true): _*)
        .addParams(FormSerializable.serialize("page", page, FormStyleFormat.FORM, true): _*)
        .addParams(FormSerializable.serialize("per_page", perPage, FormStyleFormat.FORM, true): _*)

    basicRequest
      .method(Method.GET, requestURL)
      .contentType("application/json")
      .auth(authConfig)
      .response(asJson[ListLoadBalancersResponse])

  /**
   * Removes a target from a Load Balancer. 
   * 
   * Expected answers:
   *   code 201 : RemoveTargetResponse (The `action` key contains the `remove_target` Action.)
   * 
   * Available security schemes:
   *   APIToken (http)
   * 
   * @param id ID of the Load Balancer.
   * @param removeTargetRequest 
   */
  def removeTarget(id: Long, removeTargetRequest: RemoveTargetRequest)(using Auth <:< hcloud.Authorization.BearerToken): sttp.client4.Request[Either[ResponseException[String], RemoveTargetResponse]] =
    val idPathParam = PathSerializable.serialize("id", id, PathStyleFormat.SIMPLE, false)
    val requestURL =
      uri"$baseUrl/load_balancers/${idPathParam}/actions/remove_target"

    basicRequest
      .method(Method.POST, requestURL)
      .contentType("application/json")
      .auth(authConfig)
      .body(asJson(removeTargetRequest))
      .response(asJson[RemoveTargetResponse])

  /**
   * Updates a Load Balancer. You can update a Load Balancer’s name and a Load Balancer’s labels.  Note: if the Load Balancer object changes during the request, the response will be a “conflict” error. 
   * 
   * Expected answers:
   *   code 200 : ReplaceLoadBalancerResponse (The `load_balancer` key contains the updated Load Balancer.)
   * 
   * Available security schemes:
   *   APIToken (http)
   * 
   * @param id ID of the Load Balancer.
   * @param replaceLoadBalancerRequest 
   */
  def replaceLoadBalancer(id: Long, replaceLoadBalancerRequest: ReplaceLoadBalancerRequest)(using Auth <:< hcloud.Authorization.BearerToken): sttp.client4.Request[Either[ResponseException[String], ReplaceLoadBalancerResponse]] =
    val idPathParam = PathSerializable.serialize("id", id, PathStyleFormat.SIMPLE, false)
    val requestURL =
      uri"$baseUrl/load_balancers/${idPathParam}"

    basicRequest
      .method(Method.PUT, requestURL)
      .contentType("application/json")
      .auth(authConfig)
      .body(asJson(replaceLoadBalancerRequest))
      .response(asJson[ReplaceLoadBalancerResponse])

  /**
   * Updates a Load Balancer Service.  #### Call specific error codes  | Code                       | Description                                             | |----------------------------|---------------------------------------------------------| | `source_port_already_used` | The source port you are trying to add is already in use | 
   * 
   * Expected answers:
   *   code 201 : UpdateServiceResponse (The `action` key contains the `update_service` Action.)
   * 
   * Available security schemes:
   *   APIToken (http)
   * 
   * @param id ID of the Load Balancer.
   * @param body 
   */
  def updateService(id: Long, body: UpdateLoadBalancerService)(using Auth <:< hcloud.Authorization.BearerToken): sttp.client4.Request[Either[ResponseException[String], UpdateServiceResponse]] =
    val idPathParam = PathSerializable.serialize("id", id, PathStyleFormat.SIMPLE, false)
    val requestURL =
      uri"$baseUrl/load_balancers/${idPathParam}/actions/update_service"

    basicRequest
      .method(Method.POST, requestURL)
      .contentType("application/json")
      .auth(authConfig)
      .body(asJson(body))
      .response(asJson[UpdateServiceResponse])

end LoadBalancers